// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides

part of 'splash_bloc.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more informations: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
class _$SplashEventTearOff {
  const _$SplashEventTearOff();

  _IntialSplashEvent initial() {
    return const _IntialSplashEvent();
  }

  _SelectedRoleSplashEvent selectedRole() {
    return const _SelectedRoleSplashEvent();
  }
}

/// @nodoc
const $SplashEvent = _$SplashEventTearOff();

/// @nodoc
mixin _$SplashEvent {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() selectedRole,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? selectedRole,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_IntialSplashEvent value) initial,
    required TResult Function(_SelectedRoleSplashEvent value) selectedRole,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_IntialSplashEvent value)? initial,
    TResult Function(_SelectedRoleSplashEvent value)? selectedRole,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SplashEventCopyWith<$Res> {
  factory $SplashEventCopyWith(
          SplashEvent value, $Res Function(SplashEvent) then) =
      _$SplashEventCopyWithImpl<$Res>;
}

/// @nodoc
class _$SplashEventCopyWithImpl<$Res> implements $SplashEventCopyWith<$Res> {
  _$SplashEventCopyWithImpl(this._value, this._then);

  final SplashEvent _value;
  // ignore: unused_field
  final $Res Function(SplashEvent) _then;
}

/// @nodoc
abstract class _$IntialSplashEventCopyWith<$Res> {
  factory _$IntialSplashEventCopyWith(
          _IntialSplashEvent value, $Res Function(_IntialSplashEvent) then) =
      __$IntialSplashEventCopyWithImpl<$Res>;
}

/// @nodoc
class __$IntialSplashEventCopyWithImpl<$Res>
    extends _$SplashEventCopyWithImpl<$Res>
    implements _$IntialSplashEventCopyWith<$Res> {
  __$IntialSplashEventCopyWithImpl(
      _IntialSplashEvent _value, $Res Function(_IntialSplashEvent) _then)
      : super(_value, (v) => _then(v as _IntialSplashEvent));

  @override
  _IntialSplashEvent get _value => super._value as _IntialSplashEvent;
}

/// @nodoc

class _$_IntialSplashEvent implements _IntialSplashEvent {
  const _$_IntialSplashEvent();

  @override
  String toString() {
    return 'SplashEvent.initial()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _IntialSplashEvent);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() selectedRole,
  }) {
    return initial();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? selectedRole,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_IntialSplashEvent value) initial,
    required TResult Function(_SelectedRoleSplashEvent value) selectedRole,
  }) {
    return initial(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_IntialSplashEvent value)? initial,
    TResult Function(_SelectedRoleSplashEvent value)? selectedRole,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial(this);
    }
    return orElse();
  }
}

abstract class _IntialSplashEvent implements SplashEvent {
  const factory _IntialSplashEvent() = _$_IntialSplashEvent;
}

/// @nodoc
abstract class _$SelectedRoleSplashEventCopyWith<$Res> {
  factory _$SelectedRoleSplashEventCopyWith(_SelectedRoleSplashEvent value,
          $Res Function(_SelectedRoleSplashEvent) then) =
      __$SelectedRoleSplashEventCopyWithImpl<$Res>;
}

/// @nodoc
class __$SelectedRoleSplashEventCopyWithImpl<$Res>
    extends _$SplashEventCopyWithImpl<$Res>
    implements _$SelectedRoleSplashEventCopyWith<$Res> {
  __$SelectedRoleSplashEventCopyWithImpl(_SelectedRoleSplashEvent _value,
      $Res Function(_SelectedRoleSplashEvent) _then)
      : super(_value, (v) => _then(v as _SelectedRoleSplashEvent));

  @override
  _SelectedRoleSplashEvent get _value =>
      super._value as _SelectedRoleSplashEvent;
}

/// @nodoc

class _$_SelectedRoleSplashEvent implements _SelectedRoleSplashEvent {
  const _$_SelectedRoleSplashEvent();

  @override
  String toString() {
    return 'SplashEvent.selectedRole()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _SelectedRoleSplashEvent);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() selectedRole,
  }) {
    return selectedRole();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? selectedRole,
    required TResult orElse(),
  }) {
    if (selectedRole != null) {
      return selectedRole();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_IntialSplashEvent value) initial,
    required TResult Function(_SelectedRoleSplashEvent value) selectedRole,
  }) {
    return selectedRole(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_IntialSplashEvent value)? initial,
    TResult Function(_SelectedRoleSplashEvent value)? selectedRole,
    required TResult orElse(),
  }) {
    if (selectedRole != null) {
      return selectedRole(this);
    }
    return orElse();
  }
}

abstract class _SelectedRoleSplashEvent implements SplashEvent {
  const factory _SelectedRoleSplashEvent() = _$_SelectedRoleSplashEvent;
}

/// @nodoc
class _$SplashStateTearOff {
  const _$SplashStateTearOff();

  IntialSplashState initial() {
    return const IntialSplashState();
  }

  SplashScreenState splash() {
    return const SplashScreenState();
  }

  SelectedRoleSplashState selectedRole() {
    return const SelectedRoleSplashState();
  }

  HunterSplashState hunter() {
    return const HunterSplashState();
  }

  EmployerSplashState employer() {
    return const EmployerSplashState();
  }
}

/// @nodoc
const $SplashState = _$SplashStateTearOff();

/// @nodoc
mixin _$SplashState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() splash,
    required TResult Function() selectedRole,
    required TResult Function() hunter,
    required TResult Function() employer,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? splash,
    TResult Function()? selectedRole,
    TResult Function()? hunter,
    TResult Function()? employer,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(IntialSplashState value) initial,
    required TResult Function(SplashScreenState value) splash,
    required TResult Function(SelectedRoleSplashState value) selectedRole,
    required TResult Function(HunterSplashState value) hunter,
    required TResult Function(EmployerSplashState value) employer,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(IntialSplashState value)? initial,
    TResult Function(SplashScreenState value)? splash,
    TResult Function(SelectedRoleSplashState value)? selectedRole,
    TResult Function(HunterSplashState value)? hunter,
    TResult Function(EmployerSplashState value)? employer,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SplashStateCopyWith<$Res> {
  factory $SplashStateCopyWith(
          SplashState value, $Res Function(SplashState) then) =
      _$SplashStateCopyWithImpl<$Res>;
}

/// @nodoc
class _$SplashStateCopyWithImpl<$Res> implements $SplashStateCopyWith<$Res> {
  _$SplashStateCopyWithImpl(this._value, this._then);

  final SplashState _value;
  // ignore: unused_field
  final $Res Function(SplashState) _then;
}

/// @nodoc
abstract class $IntialSplashStateCopyWith<$Res> {
  factory $IntialSplashStateCopyWith(
          IntialSplashState value, $Res Function(IntialSplashState) then) =
      _$IntialSplashStateCopyWithImpl<$Res>;
}

/// @nodoc
class _$IntialSplashStateCopyWithImpl<$Res>
    extends _$SplashStateCopyWithImpl<$Res>
    implements $IntialSplashStateCopyWith<$Res> {
  _$IntialSplashStateCopyWithImpl(
      IntialSplashState _value, $Res Function(IntialSplashState) _then)
      : super(_value, (v) => _then(v as IntialSplashState));

  @override
  IntialSplashState get _value => super._value as IntialSplashState;
}

/// @nodoc

class _$IntialSplashState implements IntialSplashState {
  const _$IntialSplashState();

  @override
  String toString() {
    return 'SplashState.initial()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is IntialSplashState);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() splash,
    required TResult Function() selectedRole,
    required TResult Function() hunter,
    required TResult Function() employer,
  }) {
    return initial();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? splash,
    TResult Function()? selectedRole,
    TResult Function()? hunter,
    TResult Function()? employer,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(IntialSplashState value) initial,
    required TResult Function(SplashScreenState value) splash,
    required TResult Function(SelectedRoleSplashState value) selectedRole,
    required TResult Function(HunterSplashState value) hunter,
    required TResult Function(EmployerSplashState value) employer,
  }) {
    return initial(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(IntialSplashState value)? initial,
    TResult Function(SplashScreenState value)? splash,
    TResult Function(SelectedRoleSplashState value)? selectedRole,
    TResult Function(HunterSplashState value)? hunter,
    TResult Function(EmployerSplashState value)? employer,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial(this);
    }
    return orElse();
  }
}

abstract class IntialSplashState implements SplashState {
  const factory IntialSplashState() = _$IntialSplashState;
}

/// @nodoc
abstract class $SplashScreenStateCopyWith<$Res> {
  factory $SplashScreenStateCopyWith(
          SplashScreenState value, $Res Function(SplashScreenState) then) =
      _$SplashScreenStateCopyWithImpl<$Res>;
}

/// @nodoc
class _$SplashScreenStateCopyWithImpl<$Res>
    extends _$SplashStateCopyWithImpl<$Res>
    implements $SplashScreenStateCopyWith<$Res> {
  _$SplashScreenStateCopyWithImpl(
      SplashScreenState _value, $Res Function(SplashScreenState) _then)
      : super(_value, (v) => _then(v as SplashScreenState));

  @override
  SplashScreenState get _value => super._value as SplashScreenState;
}

/// @nodoc

class _$SplashScreenState implements SplashScreenState {
  const _$SplashScreenState();

  @override
  String toString() {
    return 'SplashState.splash()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is SplashScreenState);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() splash,
    required TResult Function() selectedRole,
    required TResult Function() hunter,
    required TResult Function() employer,
  }) {
    return splash();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? splash,
    TResult Function()? selectedRole,
    TResult Function()? hunter,
    TResult Function()? employer,
    required TResult orElse(),
  }) {
    if (splash != null) {
      return splash();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(IntialSplashState value) initial,
    required TResult Function(SplashScreenState value) splash,
    required TResult Function(SelectedRoleSplashState value) selectedRole,
    required TResult Function(HunterSplashState value) hunter,
    required TResult Function(EmployerSplashState value) employer,
  }) {
    return splash(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(IntialSplashState value)? initial,
    TResult Function(SplashScreenState value)? splash,
    TResult Function(SelectedRoleSplashState value)? selectedRole,
    TResult Function(HunterSplashState value)? hunter,
    TResult Function(EmployerSplashState value)? employer,
    required TResult orElse(),
  }) {
    if (splash != null) {
      return splash(this);
    }
    return orElse();
  }
}

abstract class SplashScreenState implements SplashState {
  const factory SplashScreenState() = _$SplashScreenState;
}

/// @nodoc
abstract class $SelectedRoleSplashStateCopyWith<$Res> {
  factory $SelectedRoleSplashStateCopyWith(SelectedRoleSplashState value,
          $Res Function(SelectedRoleSplashState) then) =
      _$SelectedRoleSplashStateCopyWithImpl<$Res>;
}

/// @nodoc
class _$SelectedRoleSplashStateCopyWithImpl<$Res>
    extends _$SplashStateCopyWithImpl<$Res>
    implements $SelectedRoleSplashStateCopyWith<$Res> {
  _$SelectedRoleSplashStateCopyWithImpl(SelectedRoleSplashState _value,
      $Res Function(SelectedRoleSplashState) _then)
      : super(_value, (v) => _then(v as SelectedRoleSplashState));

  @override
  SelectedRoleSplashState get _value => super._value as SelectedRoleSplashState;
}

/// @nodoc

class _$SelectedRoleSplashState implements SelectedRoleSplashState {
  const _$SelectedRoleSplashState();

  @override
  String toString() {
    return 'SplashState.selectedRole()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is SelectedRoleSplashState);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() splash,
    required TResult Function() selectedRole,
    required TResult Function() hunter,
    required TResult Function() employer,
  }) {
    return selectedRole();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? splash,
    TResult Function()? selectedRole,
    TResult Function()? hunter,
    TResult Function()? employer,
    required TResult orElse(),
  }) {
    if (selectedRole != null) {
      return selectedRole();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(IntialSplashState value) initial,
    required TResult Function(SplashScreenState value) splash,
    required TResult Function(SelectedRoleSplashState value) selectedRole,
    required TResult Function(HunterSplashState value) hunter,
    required TResult Function(EmployerSplashState value) employer,
  }) {
    return selectedRole(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(IntialSplashState value)? initial,
    TResult Function(SplashScreenState value)? splash,
    TResult Function(SelectedRoleSplashState value)? selectedRole,
    TResult Function(HunterSplashState value)? hunter,
    TResult Function(EmployerSplashState value)? employer,
    required TResult orElse(),
  }) {
    if (selectedRole != null) {
      return selectedRole(this);
    }
    return orElse();
  }
}

abstract class SelectedRoleSplashState implements SplashState {
  const factory SelectedRoleSplashState() = _$SelectedRoleSplashState;
}

/// @nodoc
abstract class $HunterSplashStateCopyWith<$Res> {
  factory $HunterSplashStateCopyWith(
          HunterSplashState value, $Res Function(HunterSplashState) then) =
      _$HunterSplashStateCopyWithImpl<$Res>;
}

/// @nodoc
class _$HunterSplashStateCopyWithImpl<$Res>
    extends _$SplashStateCopyWithImpl<$Res>
    implements $HunterSplashStateCopyWith<$Res> {
  _$HunterSplashStateCopyWithImpl(
      HunterSplashState _value, $Res Function(HunterSplashState) _then)
      : super(_value, (v) => _then(v as HunterSplashState));

  @override
  HunterSplashState get _value => super._value as HunterSplashState;
}

/// @nodoc

class _$HunterSplashState implements HunterSplashState {
  const _$HunterSplashState();

  @override
  String toString() {
    return 'SplashState.hunter()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is HunterSplashState);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() splash,
    required TResult Function() selectedRole,
    required TResult Function() hunter,
    required TResult Function() employer,
  }) {
    return hunter();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? splash,
    TResult Function()? selectedRole,
    TResult Function()? hunter,
    TResult Function()? employer,
    required TResult orElse(),
  }) {
    if (hunter != null) {
      return hunter();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(IntialSplashState value) initial,
    required TResult Function(SplashScreenState value) splash,
    required TResult Function(SelectedRoleSplashState value) selectedRole,
    required TResult Function(HunterSplashState value) hunter,
    required TResult Function(EmployerSplashState value) employer,
  }) {
    return hunter(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(IntialSplashState value)? initial,
    TResult Function(SplashScreenState value)? splash,
    TResult Function(SelectedRoleSplashState value)? selectedRole,
    TResult Function(HunterSplashState value)? hunter,
    TResult Function(EmployerSplashState value)? employer,
    required TResult orElse(),
  }) {
    if (hunter != null) {
      return hunter(this);
    }
    return orElse();
  }
}

abstract class HunterSplashState implements SplashState {
  const factory HunterSplashState() = _$HunterSplashState;
}

/// @nodoc
abstract class $EmployerSplashStateCopyWith<$Res> {
  factory $EmployerSplashStateCopyWith(
          EmployerSplashState value, $Res Function(EmployerSplashState) then) =
      _$EmployerSplashStateCopyWithImpl<$Res>;
}

/// @nodoc
class _$EmployerSplashStateCopyWithImpl<$Res>
    extends _$SplashStateCopyWithImpl<$Res>
    implements $EmployerSplashStateCopyWith<$Res> {
  _$EmployerSplashStateCopyWithImpl(
      EmployerSplashState _value, $Res Function(EmployerSplashState) _then)
      : super(_value, (v) => _then(v as EmployerSplashState));

  @override
  EmployerSplashState get _value => super._value as EmployerSplashState;
}

/// @nodoc

class _$EmployerSplashState implements EmployerSplashState {
  const _$EmployerSplashState();

  @override
  String toString() {
    return 'SplashState.employer()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is EmployerSplashState);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() splash,
    required TResult Function() selectedRole,
    required TResult Function() hunter,
    required TResult Function() employer,
  }) {
    return employer();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? splash,
    TResult Function()? selectedRole,
    TResult Function()? hunter,
    TResult Function()? employer,
    required TResult orElse(),
  }) {
    if (employer != null) {
      return employer();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(IntialSplashState value) initial,
    required TResult Function(SplashScreenState value) splash,
    required TResult Function(SelectedRoleSplashState value) selectedRole,
    required TResult Function(HunterSplashState value) hunter,
    required TResult Function(EmployerSplashState value) employer,
  }) {
    return employer(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(IntialSplashState value)? initial,
    TResult Function(SplashScreenState value)? splash,
    TResult Function(SelectedRoleSplashState value)? selectedRole,
    TResult Function(HunterSplashState value)? hunter,
    TResult Function(EmployerSplashState value)? employer,
    required TResult orElse(),
  }) {
    if (employer != null) {
      return employer(this);
    }
    return orElse();
  }
}

abstract class EmployerSplashState implements SplashState {
  const factory EmployerSplashState() = _$EmployerSplashState;
}
