// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides

part of 'announce_e_cubit.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more informations: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
class _$AnnounceEStateTearOff {
  const _$AnnounceEStateTearOff();

  _LoadingAnnounceEState loading() {
    return const _LoadingAnnounceEState();
  }

  _LoadedAnnounceEState loaded(
      {required List<AnnounceE> announce,
      required List<String> announceTitles,
      required List<String> employmentTypes,
      required List<String> tools,
      required List<SkillState> skills,
      required String country,
      required String title,
      required String skill,
      required bool isAdd}) {
    return _LoadedAnnounceEState(
      announce: announce,
      announceTitles: announceTitles,
      employmentTypes: employmentTypes,
      tools: tools,
      skills: skills,
      country: country,
      title: title,
      skill: skill,
      isAdd: isAdd,
    );
  }
}

/// @nodoc
const $AnnounceEState = _$AnnounceEStateTearOff();

/// @nodoc
mixin _$AnnounceEState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loading,
    required TResult Function(
            List<AnnounceE> announce,
            List<String> announceTitles,
            List<String> employmentTypes,
            List<String> tools,
            List<SkillState> skills,
            String country,
            String title,
            String skill,
            bool isAdd)
        loaded,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loading,
    TResult Function(
            List<AnnounceE> announce,
            List<String> announceTitles,
            List<String> employmentTypes,
            List<String> tools,
            List<SkillState> skills,
            String country,
            String title,
            String skill,
            bool isAdd)?
        loaded,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_LoadingAnnounceEState value) loading,
    required TResult Function(_LoadedAnnounceEState value) loaded,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_LoadingAnnounceEState value)? loading,
    TResult Function(_LoadedAnnounceEState value)? loaded,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AnnounceEStateCopyWith<$Res> {
  factory $AnnounceEStateCopyWith(
          AnnounceEState value, $Res Function(AnnounceEState) then) =
      _$AnnounceEStateCopyWithImpl<$Res>;
}

/// @nodoc
class _$AnnounceEStateCopyWithImpl<$Res>
    implements $AnnounceEStateCopyWith<$Res> {
  _$AnnounceEStateCopyWithImpl(this._value, this._then);

  final AnnounceEState _value;
  // ignore: unused_field
  final $Res Function(AnnounceEState) _then;
}

/// @nodoc
abstract class _$LoadingAnnounceEStateCopyWith<$Res> {
  factory _$LoadingAnnounceEStateCopyWith(_LoadingAnnounceEState value,
          $Res Function(_LoadingAnnounceEState) then) =
      __$LoadingAnnounceEStateCopyWithImpl<$Res>;
}

/// @nodoc
class __$LoadingAnnounceEStateCopyWithImpl<$Res>
    extends _$AnnounceEStateCopyWithImpl<$Res>
    implements _$LoadingAnnounceEStateCopyWith<$Res> {
  __$LoadingAnnounceEStateCopyWithImpl(_LoadingAnnounceEState _value,
      $Res Function(_LoadingAnnounceEState) _then)
      : super(_value, (v) => _then(v as _LoadingAnnounceEState));

  @override
  _LoadingAnnounceEState get _value => super._value as _LoadingAnnounceEState;
}

/// @nodoc

class _$_LoadingAnnounceEState implements _LoadingAnnounceEState {
  const _$_LoadingAnnounceEState();

  @override
  String toString() {
    return 'AnnounceEState.loading()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _LoadingAnnounceEState);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loading,
    required TResult Function(
            List<AnnounceE> announce,
            List<String> announceTitles,
            List<String> employmentTypes,
            List<String> tools,
            List<SkillState> skills,
            String country,
            String title,
            String skill,
            bool isAdd)
        loaded,
  }) {
    return loading();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loading,
    TResult Function(
            List<AnnounceE> announce,
            List<String> announceTitles,
            List<String> employmentTypes,
            List<String> tools,
            List<SkillState> skills,
            String country,
            String title,
            String skill,
            bool isAdd)?
        loaded,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_LoadingAnnounceEState value) loading,
    required TResult Function(_LoadedAnnounceEState value) loaded,
  }) {
    return loading(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_LoadingAnnounceEState value)? loading,
    TResult Function(_LoadedAnnounceEState value)? loaded,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading(this);
    }
    return orElse();
  }
}

abstract class _LoadingAnnounceEState implements AnnounceEState {
  const factory _LoadingAnnounceEState() = _$_LoadingAnnounceEState;
}

/// @nodoc
abstract class _$LoadedAnnounceEStateCopyWith<$Res> {
  factory _$LoadedAnnounceEStateCopyWith(_LoadedAnnounceEState value,
          $Res Function(_LoadedAnnounceEState) then) =
      __$LoadedAnnounceEStateCopyWithImpl<$Res>;
  $Res call(
      {List<AnnounceE> announce,
      List<String> announceTitles,
      List<String> employmentTypes,
      List<String> tools,
      List<SkillState> skills,
      String country,
      String title,
      String skill,
      bool isAdd});
}

/// @nodoc
class __$LoadedAnnounceEStateCopyWithImpl<$Res>
    extends _$AnnounceEStateCopyWithImpl<$Res>
    implements _$LoadedAnnounceEStateCopyWith<$Res> {
  __$LoadedAnnounceEStateCopyWithImpl(
      _LoadedAnnounceEState _value, $Res Function(_LoadedAnnounceEState) _then)
      : super(_value, (v) => _then(v as _LoadedAnnounceEState));

  @override
  _LoadedAnnounceEState get _value => super._value as _LoadedAnnounceEState;

  @override
  $Res call({
    Object? announce = freezed,
    Object? announceTitles = freezed,
    Object? employmentTypes = freezed,
    Object? tools = freezed,
    Object? skills = freezed,
    Object? country = freezed,
    Object? title = freezed,
    Object? skill = freezed,
    Object? isAdd = freezed,
  }) {
    return _then(_LoadedAnnounceEState(
      announce: announce == freezed
          ? _value.announce
          : announce // ignore: cast_nullable_to_non_nullable
              as List<AnnounceE>,
      announceTitles: announceTitles == freezed
          ? _value.announceTitles
          : announceTitles // ignore: cast_nullable_to_non_nullable
              as List<String>,
      employmentTypes: employmentTypes == freezed
          ? _value.employmentTypes
          : employmentTypes // ignore: cast_nullable_to_non_nullable
              as List<String>,
      tools: tools == freezed
          ? _value.tools
          : tools // ignore: cast_nullable_to_non_nullable
              as List<String>,
      skills: skills == freezed
          ? _value.skills
          : skills // ignore: cast_nullable_to_non_nullable
              as List<SkillState>,
      country: country == freezed
          ? _value.country
          : country // ignore: cast_nullable_to_non_nullable
              as String,
      title: title == freezed
          ? _value.title
          : title // ignore: cast_nullable_to_non_nullable
              as String,
      skill: skill == freezed
          ? _value.skill
          : skill // ignore: cast_nullable_to_non_nullable
              as String,
      isAdd: isAdd == freezed
          ? _value.isAdd
          : isAdd // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc

class _$_LoadedAnnounceEState implements _LoadedAnnounceEState {
  const _$_LoadedAnnounceEState(
      {required this.announce,
      required this.announceTitles,
      required this.employmentTypes,
      required this.tools,
      required this.skills,
      required this.country,
      required this.title,
      required this.skill,
      required this.isAdd});

  @override
  final List<AnnounceE> announce;
  @override
  final List<String> announceTitles;
  @override
  final List<String> employmentTypes;
  @override
  final List<String> tools;
  @override
  final List<SkillState> skills;
  @override
  final String country;
  @override
  final String title;
  @override
  final String skill;
  @override
  final bool isAdd;

  @override
  String toString() {
    return 'AnnounceEState.loaded(announce: $announce, announceTitles: $announceTitles, employmentTypes: $employmentTypes, tools: $tools, skills: $skills, country: $country, title: $title, skill: $skill, isAdd: $isAdd)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _LoadedAnnounceEState &&
            (identical(other.announce, announce) ||
                const DeepCollectionEquality()
                    .equals(other.announce, announce)) &&
            (identical(other.announceTitles, announceTitles) ||
                const DeepCollectionEquality()
                    .equals(other.announceTitles, announceTitles)) &&
            (identical(other.employmentTypes, employmentTypes) ||
                const DeepCollectionEquality()
                    .equals(other.employmentTypes, employmentTypes)) &&
            (identical(other.tools, tools) ||
                const DeepCollectionEquality().equals(other.tools, tools)) &&
            (identical(other.skills, skills) ||
                const DeepCollectionEquality().equals(other.skills, skills)) &&
            (identical(other.country, country) ||
                const DeepCollectionEquality()
                    .equals(other.country, country)) &&
            (identical(other.title, title) ||
                const DeepCollectionEquality().equals(other.title, title)) &&
            (identical(other.skill, skill) ||
                const DeepCollectionEquality().equals(other.skill, skill)) &&
            (identical(other.isAdd, isAdd) ||
                const DeepCollectionEquality().equals(other.isAdd, isAdd)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(announce) ^
      const DeepCollectionEquality().hash(announceTitles) ^
      const DeepCollectionEquality().hash(employmentTypes) ^
      const DeepCollectionEquality().hash(tools) ^
      const DeepCollectionEquality().hash(skills) ^
      const DeepCollectionEquality().hash(country) ^
      const DeepCollectionEquality().hash(title) ^
      const DeepCollectionEquality().hash(skill) ^
      const DeepCollectionEquality().hash(isAdd);

  @JsonKey(ignore: true)
  @override
  _$LoadedAnnounceEStateCopyWith<_LoadedAnnounceEState> get copyWith =>
      __$LoadedAnnounceEStateCopyWithImpl<_LoadedAnnounceEState>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loading,
    required TResult Function(
            List<AnnounceE> announce,
            List<String> announceTitles,
            List<String> employmentTypes,
            List<String> tools,
            List<SkillState> skills,
            String country,
            String title,
            String skill,
            bool isAdd)
        loaded,
  }) {
    return loaded(announce, announceTitles, employmentTypes, tools, skills,
        country, title, skill, isAdd);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loading,
    TResult Function(
            List<AnnounceE> announce,
            List<String> announceTitles,
            List<String> employmentTypes,
            List<String> tools,
            List<SkillState> skills,
            String country,
            String title,
            String skill,
            bool isAdd)?
        loaded,
    required TResult orElse(),
  }) {
    if (loaded != null) {
      return loaded(announce, announceTitles, employmentTypes, tools, skills,
          country, title, skill, isAdd);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_LoadingAnnounceEState value) loading,
    required TResult Function(_LoadedAnnounceEState value) loaded,
  }) {
    return loaded(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_LoadingAnnounceEState value)? loading,
    TResult Function(_LoadedAnnounceEState value)? loaded,
    required TResult orElse(),
  }) {
    if (loaded != null) {
      return loaded(this);
    }
    return orElse();
  }
}

abstract class _LoadedAnnounceEState implements AnnounceEState {
  const factory _LoadedAnnounceEState(
      {required List<AnnounceE> announce,
      required List<String> announceTitles,
      required List<String> employmentTypes,
      required List<String> tools,
      required List<SkillState> skills,
      required String country,
      required String title,
      required String skill,
      required bool isAdd}) = _$_LoadedAnnounceEState;

  List<AnnounceE> get announce => throw _privateConstructorUsedError;
  List<String> get announceTitles => throw _privateConstructorUsedError;
  List<String> get employmentTypes => throw _privateConstructorUsedError;
  List<String> get tools => throw _privateConstructorUsedError;
  List<SkillState> get skills => throw _privateConstructorUsedError;
  String get country => throw _privateConstructorUsedError;
  String get title => throw _privateConstructorUsedError;
  String get skill => throw _privateConstructorUsedError;
  bool get isAdd => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  _$LoadedAnnounceEStateCopyWith<_LoadedAnnounceEState> get copyWith =>
      throw _privateConstructorUsedError;
}
